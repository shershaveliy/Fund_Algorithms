# Лекция 2
## Работа с файлами
fopen

fclose

fgetc

fgets

При обработке файла надо использовать один цикл для чтения символов  из файла.
## Обработка лексем
```
Найти самое длинное слово в файле
"Hello!!! World!!,,12345"
Нужно экранировать текущий символ и предыдущий

FILE * f = NULL;
char buff[SIZE];
char ch, pch = 0;
char * ptr =buff;

f = (fopen("1.txt", "r")==NULL){
    
    perror("Error");
    printf("Bad file");
    return -1;
}

while((ch = fgetc(fi)) != EOF){
    if(isalnum(ch)){
        *ptr++ = ch;
    }
    if(!isalnum(ch) && isalnum(pch)){
        *ptr = 0; это то же самое что и *ptr = '\0'
        printf("%s\n", buff); // обработка буфера
        ptr = buff;
    }
    ptr = ch;
}

do{
    ch =fgetc(fi);
    .
    .
    .
    pch = ch;
}
while(ch != EOF); // Эта часть исправляет ошибку конца цикла при обработке конца файла
```
## Функции в Си
Локальную переменную можно пометить ключевым словом static. Переменные static лежат в области данных. Такие переменные сохраняют своё значение с прошлого вызова функции.

```
<ret_type> f_name(.....){
    .
    .
    .
    return vsl
}
```
## Способы передачи аргументов
Передача по значению
```
int foo(int x){
    x *= 10;
    return 2 + x;
}

int main(){
    int y = 5;
    int t;
    z = foo(y);
    return 0;
}
```
Передача по указателю 

Никогда нельз передавать в функции указатели на локальные объекты!!! В функции создали массив и передали указатель на него в другую функцию. В таком случае как только мы выйдем из функции данные сотрутся. 

Задача на собесе. Что произойдет?

```c

int n = 10;

printf("%d %d %d\n", ++n, ++n, ++n);
```

## Модификатор const
Хороший тон - не использовать "магические константы"

## Динамическая память
```c
malloc
realloc // Влияет на производительность тк копирует старые данные на новое место. Если передать NULL то выделится память
calloc // то же самое что и malloc но инециируется нулями
free
// Надо минимизировать опирации выделения памяти, потому что они долгие и трудно выполнимые.
