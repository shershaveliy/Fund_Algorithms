# Лекция 2
## Работа с файлами
fopen

fclose

fgetc

fgets

При обработке файла надо использовать один цикл для чтения символов  из файла.
## Обработка лексем
```c
Найти самое длинное слово в файле
"Hello!!! World!!,,12345"
Нужно экранировать текущий символ и предыдущий

FILE * f = NULL;
char buff[SIZE];
char ch, pch = 0;
char * ptr =buff;

f = (fopen("1.txt", "r")==NULL){
    
    perror("Error");
    printf("Bad file");
    return -1;
}

while((ch = fgetc(fi)) != EOF){
    if(isalnum(ch)){
        *ptr++ = ch;
    }
    if(!isalnum(ch) && isalnum(pch)){
        *ptr = 0; это то же самое что и *ptr = '\0'
        printf("%s\n", buff); // обработка буфера
        ptr = buff;
    }
    ptr = ch;
}

do{
    ch =fgetc(fi);
    .
    .
    .
    pch = ch;
}
while(ch != EOF); // Эта часть исправляет ошибку конца цикла при обработке конца файла
```
## Функции в Си
Локальную переменную можно пометить ключевым словом static. Переменные static лежат в области данных. Такие переменные сохраняют своё значение с прошлого вызова функции.

```c
<ret_type> f_name(.....){
    .
    .
    .
    return vsl
}
```
## Способы передачи аргументов
Передача по значению
```c
int foo(int x){
    x *= 10;
    return 2 + x;
}

int main(){
    int y = 5;
    int t;
    z = foo(y);
    return 0;
}
```
Передача по указателю 

Никогда нельз передавать в функции указатели на локальные объекты!!! В функции создали массив и передали указатель на него в другую функцию. В таком случае как только мы выйдем из функции данные сотрутся. 

Задача на собесе. Что произойдет?

```c

int n = 10;

printf("%d %d %d\n", ++n, ++n, ++n);
```

## Модификатор const
Хороший тон - не использовать "магические константы"

## Динамическая память
```c
malloc
realloc // Влияет на производительность тк копирует старые данные на новое место. Если передать NULL то выделится память
calloc // то же самое что и malloc но инециируется нулями
free
// Надо минимизировать опирации выделения памяти, потому что они долгие и трудно выполнимые.
```
Задача: Считать с клавиатуры строки (количество неизвестно, длина не больше BUFSIZE) в динамический массив и вывести его на экран.

Есть два варианта решения:
1) увеличение элементов массива на 1
2) увеличение числа элементов в два раза(то, что надо делать чтобы не использовать часто динамическое выделение памяти.)

Ограничение ввода словом STOP.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUFSIZE 256
#define STOP_WORD "STOP"

int main() {
    char buffer[BUFSIZE];
    char **strings = NULL;  // массив указателей на строки
    int count = 0;          // текущее количество строк
    int capacity = 0;       // текущая вместимость массива
    
    printf("Введите строки (для остановки введите 'STOP'):\n");
    
    while (1) {
        // Чтение строки с клавиатуры
        if (fgets(buffer, BUFSIZE, stdin) == NULL) {
            break;  // ошибка чтения или EOF
        }
        
        // Удаляем символ новой строки
        buffer[strcspn(buffer, "\n")] = '\0';
        
        // Проверка на стоп-слово
        if (strcmp(buffer, STOP_WORD) == 0) {
            break;
        }
        
        // Увеличиваем массив на 1 элемент
        char **temp = realloc(strings, (count + 1) * sizeof(char*));
        if (temp == NULL) {
            printf("Ошибка выделения памяти!\n");
            break;
        }
        strings = temp;
        capacity = count + 1;
        
        // Выделяем память для новой строки и копируем
        strings[count] = malloc(strlen(buffer) + 1);
        if (strings[count] == NULL) {
            printf("Ошибка выделения памяти для строки!\n");
            break;
        }
        strcpy(strings[count], buffer);
        
        count++;
    }
    
    // Вывод результата
    printf("\nВведенные строки (%d шт):\n", count);
    for (int i = 0; i < count; i++) {
        printf("%d: %s\n", i + 1, strings[i]);
    }
    
    // Освобождение памяти
    for (int i = 0; i < count; i++) {
        free(strings[i]);
    }
    free(strings);
    
    return 0;
}
```
## Структурный тип
## Функции с переменным числом аргументов
```c
#include <stdarg.h>

// Функция должна иметь хотя бы один фиксированный параметр
return_type function_name(fixed_param, ...) {
    // тело функции
}
```
Макросы для работы с переменными аргументами

- va_list - тип для хранения информации об аргументах

- va_start - инициализация списка аргументов

- va_arg - получение следующего аргумента

- va_end - завершение работы со списком аргументов

```c
#include <stdio.h>
#include <stdarg.h>

// Функция суммирует произвольное количество целых чисел
int sum(int count, ...) {
    int total = 0;
    
    // Объявляем список аргументов
    va_list args;
    
    // Инициализируем список (последний фиксированный параметр)
    va_start(args, count);
    
    // Обрабатываем аргументы
    for (int i = 0; i < count; i++) {
        int num = va_arg(args, int);  // получаем следующий int
        total += num;
    }
    
    // Завершаем работу со списком
    va_end(args);
    
    return total;
}

int main() {
    printf("Сумма 3 чисел: %d\n", sum(3, 10, 20, 30));        // 60
    printf("Сумма 5 чисел: %d\n", sum(5, 1, 2, 3, 4, 5));     // 15
    printf("Сумма 2 чисел: %d\n", sum(2, 100, 200));          // 300
    
    return 0;
}
```


